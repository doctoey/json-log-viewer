<!doctype html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ตัวแปลง JSON Log ให้อ่านง่าย (Enhanced)</title>
    <style>
      :root {
        --bg: #0f1419;
        --panel: #15202b;
        --muted: #8899a6;
        --text: #e6eef8;
        --accent: #1d9bf0;
        --accent-hover: #1a8cd8;
        --accent-2: #2aa7ff;
        --success: #00ba7c;
        --error: #f91880;
        --key: #ff6b6b;
        --string: #7ee787;
        --number: #ffca6b;
        --boolean: #1da1f2;
        --null: #b085ff;
        --border: rgba(255, 255, 255, 0.11);
        --glass-bg: rgba(21, 32, 43, 0.98);
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family:
          "Sarabun",
          Inter,
          system-ui,
          -apple-system,
          sans-serif;
        background: linear-gradient(120deg, #0f1419 0%, #1d2636 100%);
        color: var(--text);
        padding: 28px 0;
        min-height: 100vh;
        margin: 0;
      }

      /* Helpers */
      .hidden {
        display: none !important;
      }
      .flex {
        display: flex;
      }
      .items-center {
        align-items: center;
      }
      .justify-between {
        justify-content: space-between;
      }
      .gap-2 {
        gap: 8px;
      }
      .mt-4 {
        margin-top: 16px;
      }

      /* Layout */
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 40px 36px;
        background-color: var(--panel);
        border-radius: 32px;
        border: 1.5px solid var(--border);
        box-shadow: 0 16px 48px rgba(29, 155, 240, 0.16);
        backdrop-filter: blur(18px);
      }

      h1 {
        text-align: center;
        font-size: 2.2rem;
        margin-bottom: 32px;
        color: var(--text);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        text-shadow: 0 2px 12px rgba(29, 155, 240, 0.1);
      }

      /* Editor Areas */
      .editor-row {
        display: flex;
        gap: 28px;
        margin-top: 18px;
        justify-content: center;
      }

      .pane {
        flex: 1;
        background: rgba(255, 255, 255, 0.04);
        border: 1.5px solid rgba(29, 155, 240, 0.09);
        border-radius: 20px;
        padding: 24px;
        display: flex;
        flex-direction: column;
        transition: all 0.3s ease;
        position: relative;
        min-width: 0; /* Prevents flex overflow */
      }

      .pane.collapsed .expandable-content {
        display: none;
      }

      textarea {
        width: 100%;
        height: 200px;
        background: rgba(0, 0, 0, 0.2);
        border: 1.5px solid rgba(29, 155, 240, 0.13);
        border-radius: 12px;
        color: var(--text);
        padding: 16px;
        font-family: monospace;
        font-size: 14px;
        resize: vertical;
        transition: all 0.2s;
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(29, 155, 240, 0.15);
      }

      /* Buttons */
      .btn {
        padding: 10px 20px;
        border-radius: 99px;
        border: none;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: white;
        font-weight: 700;
        cursor: pointer;
        transition:
          transform 0.1s,
          box-shadow 0.2s;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(29, 155, 240, 0.3);
      }
      .btn:active {
        transform: scale(0.98);
      }

      .btn-ghost {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .btn-ghost:hover {
        background: rgba(255, 255, 255, 0.1);
      }

      .tool-btn {
        padding: 6px 12px;
        font-size: 13px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        color: var(--muted);
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .tool-btn:hover {
        background: rgba(29, 155, 240, 0.1);
        color: var(--accent);
      }

      /* Result Box */
      .result-box {
        margin-top: 28px;
        background: var(--glass-bg);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 24px;
        display: none;
        animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .result-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
        padding-bottom: 16px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      #status {
        font-size: 14px;
        color: var(--muted);
      }
      #status.error {
        color: var(--error);
      }
      #status.success {
        color: var(--success);
      }

      /* JSON Viewer / Tree */
      .json-viewer {
        font-family: "Menlo", "Monaco", monospace;
        font-size: 13px;
        line-height: 1.6;
        overflow-x: auto;
      }
      .jv-node {
        margin-left: 20px;
        border-left: 1px solid rgba(255, 255, 255, 0.05);
        padding-left: 5px;
      }
      .jv-toggle {
        cursor: pointer;
        user-select: none;
        display: inline-block;
        margin-right: 4px;
        color: var(--muted);
        transition: transform 0.15s;
        width: 14px;
        text-align: center;
      }
      .jv-toggle.collapsed {
        transform: rotate(-90deg);
      }
      .jv-key {
        color: var(--key);
        margin-right: 4px;
      }
      .jv-string {
        color: var(--string);
        word-break: break-all;
      }
      .jv-number {
        color: var(--number);
      }
      .jv-boolean {
        color: var(--boolean);
      }
      .jv-null {
        color: var(--null);
      }
      .jv-object-start,
      .jv-array-start {
        color: var(--text);
        cursor: pointer;
      }
      .jv-object-start:hover,
      .jv-array-start:hover {
        color: var(--accent);
      }
      .jv-collapsed-preview {
        color: var(--muted);
        font-style: italic;
        font-size: 12px;
        margin-left: 4px;
      }

      @media (max-width: 768px) {
        .editor-row {
          flex-direction: column;
        }
        .pane {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>
        <svg width="32" height="32" viewBox="0 0 24 24" fill="none">
          <rect
            x="3"
            y="3"
            width="18"
            height="18"
            rx="4"
            fill="var(--accent)"
            fill-opacity="0.2"
          />
          <path
            d="M8 16l8-8M8 8h8v8"
            stroke="var(--accent)"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
        JSON Log Viewer
      </h1>

      <!-- Editors -->
      <div class="editor-row">
        <!-- Main Input -->
        <div class="pane" id="pane-input">
          <div class="flex justify-between items-center mb-2">
            <label
              class="font-bold flex items-center gap-2"
              style="color: var(--string)"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                <path
                  d="M7 8h10M7 12h10M7 16h6"
                  stroke="currentColor"
                  stroke-width="2"
                  stroke-linecap="round"
                />
              </svg>
              Input Data
            </label>
            <div class="flex gap-2">
              <button
                class="tool-btn"
                onclick="
                  Utils.copyToClipboard(
                    document.getElementById('inputData').value,
                    this,
                  )
                "
              >
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none">
                  <path d="M9 9h6v6H9z" fill="currentColor" />
                </svg>
                Copy
              </button>
              <button class="tool-btn" onclick="Utils.clearInput('inputData')">
                Clear
              </button>
            </div>
          </div>
          <textarea
            id="inputData"
            placeholder="Paste JSON string, Log line, or Nested JSON here..."
          ></textarea>
          <div class="expandable-content">
            <p style="font-size: 12px; color: var(--muted); margin-top: 8px">
              Supports: Plain JSON, JSON inside String, Log lines with JSON
              substring.
            </p>
            <div class="mt-4 flex gap-2">
              <button class="btn" onclick="App.processInput(false)">
                Convert JSON
              </button>
            </div>
          </div>
        </div>

        <!-- Nested Input (Specialized) -->
        <div class="pane" id="pane-nested">
          <div class="flex justify-between items-center mb-2">
            <label
              class="font-bold flex items-center gap-2"
              style="color: var(--key)"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                <path
                  d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"
                  stroke="currentColor"
                  stroke-width="2"
                />
              </svg>
              Nested Value
            </label>
            <div class="flex gap-2">
              <button
                class="tool-btn"
                onclick="
                  Utils.copyToClipboard(
                    document.getElementById('inputNested').value,
                    this,
                  )
                "
              >
                Copy
              </button>
              <button
                class="tool-btn"
                onclick="Utils.clearInput('inputNested')"
              >
                Clear
              </button>
            </div>
          </div>
          <textarea
            id="inputNested"
            placeholder='{"value": "{\"log\": ...}"}'
          ></textarea>
          <div class="expandable-content">
            <p style="font-size: 12px; color: var(--key); margin-top: 8px">
              Extracts JSON from `value` field automatically.
            </p>
            <div class="mt-4">
              <button
                class="btn"
                style="background: linear-gradient(90deg, #ff6b6b, #ff8787)"
                onclick="App.processNested(false)"
              >
                Extract Nested
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Output / Result -->
      <div id="resultContainer" class="result-box">
        <div class="result-header">
          <div id="status">Ready</div>
          <div class="flex gap-2">
            <button class="tool-btn" onclick="App.toggleViewMode()">
              <span id="viewModeLabel">Show Plain</span>
            </button>
            <button
              class="tool-btn"
              id="copyResultBtn"
              onclick="Utils.copyResult()"
            >
              Copy Result
            </button>
            <button
              class="tool-btn"
              onclick="
                document.getElementById('resultContainer').style.display =
                  'none'
              "
            >
              Close
            </button>
          </div>
        </div>

        <!-- Tree View -->
        <div id="jsonTreeOutput" class="json-viewer"></div>

        <!-- Text View (Hidden by default) -->
        <textarea
          id="jsonTextOutput"
          class="hidden"
          style="height: 400px; font-size: 12px"
        ></textarea>
      </div>
    </div>

    <script>
      /**
       * Utility Functions
       */
      const Utils = {
        copyToClipboard: async (text, btnElement) => {
          if (!text) return;
          try {
            await navigator.clipboard.writeText(text);
            const originalText = btnElement.innerText;
            btnElement.innerText = "Copied!";
            btnElement.style.color = "var(--success)";
            setTimeout(() => {
              btnElement.innerText = originalText;
              btnElement.style.color = "";
            }, 2000);
            App.setStatus("Copied to clipboard", "success");
          } catch (err) {
            // Fallback
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand("copy");
            document.body.removeChild(textArea);
            App.setStatus("Copied (fallback)", "success");
          }
        },
        clearInput: (id) => {
          document.getElementById(id).value = "";
          document.getElementById(id).focus();
        },
        copyResult: () => {
          // Copy the raw JSON
          const jsonText = document.getElementById("jsonTextOutput").value;
          Utils.copyToClipboard(
            jsonText,
            document.getElementById("copyResultBtn"),
          );
        },
      };

      /**
       * Main Application Logic
       */
      const App = {
        state: {
          currentJson: null,
          viewMode: "tree", // or 'text'
        },

        init: () => {
          // Auto-convert on paste
          ["inputData", "inputNested"].forEach((id) => {
            const el = document.getElementById(id);
            if (el) {
              el.addEventListener("paste", () => {
                setTimeout(() => {
                  if (id === "inputNested") App.processNested(true);
                  else App.processInput(true);
                }, 50);
              });
            }
          });
        },

        setStatus: (msg, type = "normal") => {
          const el = document.getElementById("status");
          el.textContent = msg;
          el.className =
            type === "error" ? "error" : type === "success" ? "success" : "";

          if (type !== "error") {
            setTimeout(() => (el.textContent = ""), 4000);
          }
        },

        toggleViewMode: () => {
          const treeEl = document.getElementById("jsonTreeOutput");
          const textEl = document.getElementById("jsonTextOutput");
          const label = document.getElementById("viewModeLabel");

          if (App.state.viewMode === "tree") {
            App.state.viewMode = "text";
            treeEl.classList.add("hidden");
            textEl.classList.remove("hidden");
            label.textContent = "Show Tree";
          } else {
            App.state.viewMode = "tree";
            treeEl.classList.remove("hidden");
            textEl.classList.add("hidden");
            label.textContent = "Show Plain";
          }
        },

        displayResult: (jsonObj, msg) => {
          App.state.currentJson = jsonObj;

          document.getElementById("resultContainer").style.display = "block";
          App.setStatus(msg || "Successfully converted", "success");

          // 1. Render Tree
          const treeContainer = document.getElementById("jsonTreeOutput");
          treeContainer.innerHTML = "";
          treeContainer.appendChild(JsonViewer.render(jsonObj));

          // 2. Render Text
          document.getElementById("jsonTextOutput").value = JSON.stringify(
            jsonObj,
            null,
            2,
          );
        },

        processInput: (isAuto) => {
          const input = document.getElementById("inputData").value.trim();
          if (!input) return;

          try {
            let result = App.parseRobust(input);
            App.displayResult(
              result,
              isAuto ? "Auto-converted" : "Converted successfully",
            );
          } catch (e) {
            console.error(e);
            if (!isAuto)
              App.setStatus("Could not parse JSON: " + e.message, "error");
          }
        },

        processNested: (isAuto) => {
          const input = document.getElementById("inputNested").value.trim();
          if (!input) return;

          try {
            const outer = JSON.parse(input);
            if (!outer.value) throw new Error("No 'value' field found in JSON");

            let inner;
            try {
              inner = JSON.parse(outer.value);
            } catch (e) {
              throw new Error("The 'value' field is not valid JSON string");
            }

            App.displayResult(
              inner,
              isAuto ? "Auto-extracted nested JSON" : "Extracted successfully",
            );
          } catch (e) {
            if (!isAuto) App.setStatus(e.message, "error");
          }
        },

        // Helper to handle various "dirty" JSON scenarios
        parseRobust: (str) => {
          // 1. Try direct parse
          try {
            let obj = JSON.parse(str);
            // If it's a string, try to parse it again (double stringified)
            if (typeof obj === "string") {
              try {
                return JSON.parse(obj);
              } catch (e) {
                return obj;
              } // Return string if not json
            }
            return obj;
          } catch (e) {
            /* continue */
          }

          // 2. Try to extract JSON from a log line (find { or [ and matching } or ])
          const start = str.search(/[{}\[]/);
          if (start === -1) throw new Error("No JSON object found");

          // Simple stack-based extractor
          let stack = 0;
          let startIndex = start;
          let endIndex = -1;

          for (let i = start; i < str.length; i++) {
            if (str[i] === "{" || str[i] === "[") stack++;
            if (str[i] === "}" || str[i] === "]") {
              stack--;
              if (stack === 0) {
                endIndex = i;
                break;
              }
            }
          }

          if (endIndex !== -1) {
            const candidate = str.substring(startIndex, endIndex + 1);
            try {
              const obj = JSON.parse(candidate);
              // Check if it's stringified inside
              if (typeof obj === "string") {
                try {
                  return JSON.parse(obj);
                } catch (e) {
                  return obj;
                }
              }
              return obj;
            } catch (e2) {
              throw e2;
            }
          }

          throw new Error("Complex parsing failed");
        },
      };

      /**
       * JSON Tree Viewer Renderer
       */
      const JsonViewer = {
        render: (data) => {
          if (data === null) return JsonViewer.createSpan("null", "jv-null");
          if (typeof data === "number")
            return JsonViewer.createSpan(data, "jv-number");
          if (typeof data === "boolean")
            return JsonViewer.createSpan(data, "jv-boolean");
          if (typeof data === "string")
            return JsonViewer.createSpan(`"${data}"`, "jv-string");

          if (Array.isArray(data) || typeof data === "object") {
            const isArray = Array.isArray(data);
            const isEmpty = isArray
              ? data.length === 0
              : Object.keys(data).length === 0;

            const container = document.createElement("div");

            // Preview Header
            const start = document.createElement("span");
            if (isEmpty) {
              start.innerHTML = isArray ? "[]" : "{}";
              container.appendChild(start);
              return container;
            }

            start.className = isArray ? "jv-array-start" : "jv-object-start";
            start.innerHTML =
              `<span class="jv-toggle">▼</span>` + (isArray ? "[" : "{");

            const content = document.createElement("div");
            content.className = "jv-node";

            const keys = Object.keys(data);
            keys.forEach((key, idx) => {
              const line = document.createElement("div");
              if (!isArray) {
                line.appendChild(JsonViewer.createSpan(`"${key}"`, "jv-key"));
                line.appendChild(document.createTextNode(": "));
              }

              line.appendChild(JsonViewer.render(data[key]));
              if (idx < keys.length - 1)
                line.appendChild(document.createTextNode(","));

              content.appendChild(line);
            });

            const end = document.createElement("div");
            end.textContent = isArray ? "]" : "}";

            // Toggle Logic
            start.onclick = (e) => {
              e.stopPropagation();
              const isHidden = content.classList.contains("hidden");
              if (isHidden) {
                // Expand
                content.classList.remove("hidden");
                start.querySelector(".jv-toggle").classList.remove("collapsed");
                start.querySelector(".jv-toggle").textContent = "▼";
                start.querySelector(".jv-preview")?.remove();
              } else {
                // Collapse
                content.classList.add("hidden");
                start.querySelector(".jv-toggle").classList.add("collapsed");
                start.querySelector(".jv-toggle").textContent = "▶";

                // Add preview
                const preview = document.createElement("span");
                preview.className = "jv-collapsed-preview";
                const count = isArray
                  ? data.length + " items"
                  : keys.length + " keys";
                preview.textContent = isArray
                  ? `... ${count} ...`
                  : `... ${count} ...`;
                preview.classList.add("jv-preview");
                start.appendChild(preview);
              }
            };

            container.appendChild(start);
            container.appendChild(content);
            container.appendChild(end);
            return container;
          }
        },

        createSpan: (text, className) => {
          const span = document.createElement("span");
          span.textContent = text;
          span.className = className;
          return span;
        },
      };

      // Initialize
      window.addEventListener("DOMContentLoaded", App.init);
    </script>
  </body>
</html>
